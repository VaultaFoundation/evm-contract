# EVM token flow

![EVM flow diagram](./EVM_flow.svg)

**Transaction A**:

1. The `pushtx` action within EOS transaction A is processed by the EVM runtime contract. It carries out initial validation on the fields including calling `require_auth` on the EOS account `alice`. 
2. Sufficient EVM tokens are pulled from the EVM balance of account `0xacc2...` to cover the maximum gas costs and the value `V`. Note the arrow is bidirectional because the account will get back tokens for any unused gas and may get back addition EVM tokens from the special RAM maintainer EVM balance as incentive for freeing up storage space.
3. The value `V` of the EVM transaction goes to the `to` address `0xacc3...`. 
4. The net gas fee, which can be negative or positive, is collected from (or returned to) the sender (`0xacc2...`) and can be broken down into a storage portion and a computation portion. The storage portion of the net gas fee can also be negative or positive and it is sent to (or pulled from) the RAM maintainer EVM balance. The computation portion of the net gas is always positive. Note that the EVM tokens pulled from the sender must equal the sum of the tokens sent to the EVM balance for the `to` address, the tokens sent to the RAM maintainer EVM balance, and the computation portion of the net gas fee which is split among to other balances.
5. A fraction (configurable in the EVM runtime contract) of the computation portion of the net gas fee is sent to a recipient determined by the miner (see `fee_recipient` account in the `pushtx` action) as "write rewards" compensation for the CPU/NET costs incurred by the miner. Usually the miner will choose to use the same account for `fee_recipient` as they use for the `miner` field.
6. The remaining fraction of the computation portion of the net gas fee is sent to the special fee collection EVM balance. This is revenue collected by Trust EVM which it uses to incentive RPC providers to provide their services.

**Transaction B**:

1. The `collectfee` action within EOS transaction B is processed by the EVM runtime contract. It can be called by anyone who is willing to pay for the gas costs of the internal EVM transaction it will create to move the EVM tokens collected in the special fee collection EVM balance within the EOS environment to the official Trust EVM staking contract within the EVM environment.
2. All of the EVM tokens collected in the fee collection EVM balance, let us call this amount `F`, is removed from that balance.
3. The collected fees amounting to `F` EVM tokens is then added into another special balance that tracking all of the internal outstanding EVM balance (the total supply of EVM tokens captured within the EVM environment).
4. The EVM runtime contract then generates an inline `pushtx` action to itself. The `miner` field is kept empty which is always acceptable even if `pushtx` was not an inline action. The `fee_recipient` field is set to the `fee_recipient` specified in the `collectfee` action. The `from` field is set to a special address in the reserved range which corresponds to the `charlie` account (the account specified as the `gas_payer` in the `collectfee` action). The `flags` field does not include the `allow_revert` flag which means that if the initial EVM call is reverted, the transaction will be aborted. Finally, the `rlptx` encodes the EVM transaction that will be processed. The `value` field of this transaction is `F`. The `to` field is set to the address for the official Trust EVM staking contract within the EVM environment which is known to the EVM runtime contract. The signature fields `v`, `r`, `s` do not encode a valid signature for the EVM transaction. Instead, they encode the `from` address. The remaining fields are set appropriate to avoid having the transaction fail due to the nonce or due to gas issues.
5. The inline `pushtx` action generated by the `collectfee` action is processed by the EVM runtime contract. Since the `miner` field is empty, it will not call `require_auth`. Because the `from` address is within the reserved range, it will ensure that this is an inline action sent by the EVM runtime contract itself, or else it will abort the transaction. In addition, because the `from` address is in the reserved range, it will not validate the signature as it normally would, but instead will ensure that it has the proper encoding of the `from` address.
6. Sufficient EVM tokens are pulled from the EVM balance of the `charlie` account (note that this is now a balance within the EOS environment) to cover the maximum gas costs and the value `F`. The EVM runtime knows which account within the EOS environment to pull funds when processing this EVM transaction because it knows the account name mapped to by the `from` address within the reserved range. Note the arrow is bidirectional because the account will get back tokens for any unused gas and may get back addition EVM tokens from the special RAM maintainer EVM balance as incentive for freeing up storage space.
7. The value `F` of the EVM transaction goes to the `to` address `0xacc1...` which is the address of the staking contract. This makes the collected fees available to the staking contract to be later distributed to the various stakers proportionally.
8. Like in the case of transaction A, the net gas fee is broken down to a storage portion and a computation portion. The storage portion is sent to (or pulled from) the RAM maintainer EVM balance.
9. The configurable fraction of the computation portion of the net gas fee is sent to the `fee_recipient` account, in this case `charlie`.
10. The remaining fraction of the computation portion of the net gas fee is sent to the special fee collection EVM balance. This means that even after processing the `collectfee` action, the fee collection EVM balance will always end up with some small positive balance remaining.


